import csv
import datetime
from dateutil import parser
import os
import requests
from signal import SIGABRT
import sqlite3
import sys

from src.probe import ffprobe

def main():
  if "--token" not in sys.argv:
    print("Error: Provide token using the --token flag.")
    sys.exit(1)
  
  # () Get token
  token_index = sys.argv.index("--token") + 1
  token = sys.argv[token_index]

  # () Configuration variables
  
  

  # () Create an empty file if it doesn't exist
  tracker_file = 'voicememo_db.csv'
  if not os.path.exists(tracker_file):
    with open(tracker_file, 'w') as f:
      f.write(None)

  # () Read tracked records
  headers = ['~external_id', '~label', '~path', '~date']
  tracked_rows = []
  tracked_ids = []
  with open(tracker_file, 'r') as f:
    reader = csv.DictReader(f, headers)
    for row in reader:
      tracked_ids.append(row['~external_id'])
      tracked_rows.append(row)
    # () Delete the superfluous header row
    if len(tracked_ids):
      del tracked_ids[0]
      del tracked_rows[0]


  # () Read from Voicememo DB
  db_url = os.path.expanduser("~/Library/Application Support/com.apple.voicememos/Recordings/CloudRecordings.db")
  all_rows = []
  try:
    cx = sqlite3.connect(db_url)
    cu = cx.cursor()
    results = cu.execute('SELECT ZUNIQUEID, ZCUSTOMLABEL, ZPATH, ZDATE FROM "ZCLOUDRECORDING" ORDER BY "ZDATEFORSORTING" ASC')
    for row in results:
      all_rows.append(row)
  except sqlite3.OperationalError as e:
    print("‚ùåüíÄ‚ùå Sorry!!")
    print(e)
    exit(SIGABRT)

  # () Compare all_rows with tracked_ids
  pending_rows = []
  for row in all_rows:
    id, label, path, date = row
    if id not in tracked_ids:
      # Skip record when file is not yet synchronized.
      if not path:
        print('‚ö†Ô∏è  {} is not yet synchronized. Skipping..'.format(id))
        continue

      print("+ {} ({})".format(label, date))

      pending_rows.append({
        '~external_id': id,
        '~label': label if label else "",
        '~path': path,
        '~date': date
      })

  print('{} pending items.'.format(len(pending_rows)))
  if not len(pending_rows):
    print("Nothing to import ‚Äî bye ‚úåüèº")
    exit(0)

  # Ask to confirm (generated by AI)
  while True:
      answer = input("Do you want to continue? (yes/no): ").lower()
      if answer in ["no", "nope", "nah", "cancel", "exit", "n"]:
        print('User aborted üëãüèº ')
        exit(0)

      elif answer in ["yes", "yep", "sure", "okay", "yeah", "y"]:
        break

      else:
          print("Sorry, I didn't understand that. Please enter 'yes' or 'no'.")

  # () Import records
  try:
    for row in pending_rows:
      probe = ffprobe(row['~path'])
      created_time = parser.parse(probe.get('format').get('tags').get('creation_time'))
      duration = probe.get('format').get('duration')
      start_time = created_time - datetime.timedelta(seconds=float(duration))

      data = {
        "label": row['~label'],
        "startTime": start_time,
        "duration": duration,
      }
      files = {'audioFile': open (row['~path'], 'rb')}

      r = requests.post('http://localhost:8000/api/mementooriginalaudio/', files=files, data=data, headers={'Authorization': 'Bearer {}'.format(token)})
      try:
        r.raise_for_status()
        print('‚úÖ {}'.format(row['~label']))

        # On success, add ID to tracked IDs
        tracked_rows.append(row)

      except requests.exceptions.HTTPError as err:
        print('‚ùå -----')
        print(err)
        print('‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî')
        print(files)
        print(data['label'])
        print(data['startTime'])
        print(data['duration'])
        print(row['~external_id'])
        print('‚ùå -----')

  except Exception as e:
    print(e)


  # () Write back to tracker file
  with open(tracker_file, 'w') as f:
    dw = csv.DictWriter(f, headers)
    dw.writeheader()
    dw.writerows(tracked_rows)


if __name__ == '__main__':
  main()

